<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/07/15/hello-world/"/>
      <url>/2024/07/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hessian基础</title>
      <link href="/2024/06/14/Hessian/"/>
      <url>/2024/06/14/Hessian/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Hessian是caucho公司的工程项目，为了达到或超过 ORMI&#x2F;Java JNI 等其他跨语言&#x2F;平台调用的能力设计而出，在 2004 点发布 1.0 规范，一般称之为 Hessian ，并逐步迭代，在 Hassian jar 3.2.0 之后，采用了新的 2.0 版本的协议，一般称之为 Hessian 2.0。<br>Hessian是基于二进制的实现，传输数据更小更快，基于HTTP协议传输</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>Remote Procedure Call Protocol，远程过程调用。早在学RMI时就遇到了这个词。RPC它以标准的二进制格式来定义请求的信息（请求对象、方法、参数等），这种方法传输信息的优点之一就是跨语言及操作系统。<br>*在面向对象编程范式下，RMI其实就是RPC的一种具体实现<br>PRC协议的一次远程通信过程：</p><ol><li>客户端发起请求，并且按照RPC协议格式填充信息</li><li>填充完毕后将二进制格式文件转化为流，通过传输协议进行传输</li><li>服务端接收到流后，将其转换为二进制格式文件，并且按照RPC协议格式获取请求的信息并进行处理</li><li>处理完毕后将结果按照RPC协议格式写入二进制格式文件中并返回</li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.caucho<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hessian<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.63<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 Hessian 基于 HTTP 协议，所以通常通过 Web 应用来提供服务<br><strong>基于Servlet项目</strong><br>通过把提供服务的类注册成 Servlet 的方式来作为 Server 端进行交互。</p><ol><li><p>首先创建一个可提供服务的API接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hessian;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务端需要有一个该方法的具体实现，这里通过使该类继承自<code>com.caucho.hessian.server.HessianServlet</code>来将其标记为一个提供服务的 Servlet</p></li><li><p>创建服务端，通过把提供服务的类注册成 Servlet 的方式来作为 Server 端进行交互 . </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hessian;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.caucho.hessian.server.HessianServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">extends</span> <span class="title class_">HessianServlet</span> <span class="keyword">implements</span>  <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;baicany&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3.配置web.xml，为服务端设置映射  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;hesian&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.example.hessian.Server&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;hesian&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/hessian&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>servlet-name要设置相同，url-pattern和servlet-class为映射关系<br>表示访问&#x2F;hessian，触发相关Servlet后端类<br>4.将服务端部署上tomcat<br>项目结构是<br><img src="https://baicany.github.io/images/1718004144437-dd911142-8766-4fb8-8187-67f720a029de.png" alt="image.png"></p></li><li><p>客户端通过com.caucho.hessian.client.HessianProxyFactory工厂类创建对接口的代理对象，并进行调用  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hessian;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.caucho.hessian.client.HessianProxyFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HessianClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/hessian&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">HessianProxyFactory</span> <span class="variable">hessianProxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianProxyFactory</span>();</span><br><span class="line">        <span class="type">Greeting</span> <span class="variable">hello</span> <span class="operator">=</span> (Greeting) hessianProxyFactory.create(Greeting.class, url);</span><br><span class="line"></span><br><span class="line">        System.out.println(hello.sayHello());<span class="comment">//baicany</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="远程调用源码分析"><a href="#远程调用源码分析" class="headerlink" title="远程调用源码分析"></a><strong>远程调用</strong>源码分析</h3><p>HessianProxyFactory的实例化，即创建代理工厂<br>HessianProxyFactory hessianProxyFactory &#x3D; new HessianProxyFactory();<br><img src="https://baicany.github.io/images/1718006353847-09c225f6-41f9-4a90-8e51-40243fa6e1b7.png" alt="image.png">主要是初始化类加载器和相应resolver对象，resolver对象中则是设置好代理工厂<br>接着通过HessianProxyFactory#create方法获取接口代理类对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Greeting</span> <span class="variable">hello</span> <span class="operator">=</span> (Greeting) hessianProxyFactory.create(Greeting.class, url); </span><br></pre></td></tr></table></figure><p> 首先对url进行URL对象的封装，用实例化时的类加载器进行代理对象的加载。用动态代理的方式去返回我们的代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">create</span><span class="params">(Class&lt;?&gt; api, URL url, ClassLoader loader)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (api == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;api must not be null for HessianProxyFactory.create()&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        handler = <span class="keyword">new</span> <span class="title class_">HessianProxy</span>(url, <span class="built_in">this</span>, api);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(loader, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;api, HessianRemoteObject.class&#125;, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以看看 HessianProxy#invoke方法 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    String mangleName;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>._mangleMap) &#123;</span><br><span class="line">        mangleName = (String)<span class="built_in">this</span>._mangleMap.get(method);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先从获取mangleMap里面获取我们要的方法如果没有就会跟进下面代码去调用对应的方法.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; params.length == <span class="number">1</span> &amp;&amp; params[<span class="number">0</span>].equals(Object.class)) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; Proxy.isProxyClass(value.getClass())) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxyHandler</span> <span class="operator">=</span> Proxy.getInvocationHandler(value);</span><br><span class="line">        <span class="keyword">if</span> (!(proxyHandler <span class="keyword">instanceof</span> HessianProxy)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">HessianProxy</span> <span class="variable">handler</span> <span class="operator">=</span> (HessianProxy)proxyHandler;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="built_in">this</span>._url.equals(handler.getURL()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (methodName.equals(<span class="string">&quot;hashCode&quot;</span>) &amp;&amp; params.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="built_in">this</span>._url.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (methodName.equals(<span class="string">&quot;getHessianType&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> proxy.getClass().getInterfaces()[<span class="number">0</span>].getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (methodName.equals(<span class="string">&quot;getHessianURL&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._url.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (methodName.equals(<span class="string">&quot;toString&quot;</span>) &amp;&amp; params.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;HessianProxy[&quot;</span> + <span class="built_in">this</span>._url + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>._factory.isOverloadEnabled()) &#123;</span><br><span class="line">    mangleName = method.getName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mangleName = <span class="built_in">this</span>.mangleName(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isOverloadEnabled默认为false,那就用mangleName方法去设置mangleName.<br>然后将获取的方法存进manglemap<br>然后调用sendRequest方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HessianConnection <span class="title function_">sendRequest</span><span class="params">(String methodName, Object[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">HessianConnection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    conn = <span class="built_in">this</span>._factory.getConnectionFactory().open(<span class="built_in">this</span>._url);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    HessianConnection var14;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.addRequestHeaders(conn);</span><br></pre></td></tr></table></figure><p>先连接了url,然后加了请求头</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addRequestHeaders</span><span class="params">(HessianConnection conn)</span> &#123;</span><br><span class="line">       conn.addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;x-application/hessian&quot;</span>);</span><br><span class="line">       conn.addHeader(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;deflate&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">basicAuth</span> <span class="operator">=</span> <span class="built_in">this</span>._factory.getBasicAuth();</span><br><span class="line">       <span class="keyword">if</span> (basicAuth != <span class="literal">null</span>) &#123;</span><br><span class="line">           conn.addHeader(<span class="string">&quot;Authorization&quot;</span>, basicAuth);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后通过HessianURLConnection#getOutputstream去获取我们序列化流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    os = conn.getOutputStream();</span><br></pre></td></tr></table></figure><p> 这里是向流中写入相关数据，call方法是将方法调用信息写入进流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractHessianOutput</span> <span class="variable">out</span> <span class="operator">=</span> <span class="built_in">this</span>._factory.getHessianOutput((OutputStream)os);</span><br><span class="line">out.call(methodName, args);</span><br><span class="line">out.flush();</span><br></pre></td></tr></table></figure><p>然后再调用HessianURLConnection#sendRequest</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.sendRequest()</span><br></pre></td></tr></table></figure><p>将流的信息发出去,再从流信息获取要调用的方法,返回执行方法结果<br>最后返回这个HessianURLConnection对象<br>返回后，通过这个对象获取Input流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">is = <span class="built_in">this</span>.getInputStream(conn);</span><br></pre></td></tr></table></figure><p> 最后通过这个流获取方法调用结果  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">value = in.readReply(method.getReturnType());</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> InputStream) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="title class_">ResultInputStream</span>(conn, (InputStream)is, in, (InputStream)value);</span><br><span class="line">    is = <span class="literal">null</span>;</span><br><span class="line">    conn = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var12 = value;</span><br></pre></td></tr></table></figure><p>发现是tag是82和70的话都会调用this.object</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">readReply</span><span class="params">(Class expectedClass)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="built_in">this</span>.read();</span><br><span class="line">    <span class="keyword">if</span> (tag == <span class="number">82</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.readObject(expectedClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag == <span class="number">70</span>) &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> (HashMap)<span class="built_in">this</span>.readObject(HashMap.class);</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">this</span>.prepareFault(map);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append((<span class="type">char</span>)tag);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>((ch = <span class="built_in">this</span>.read()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append((<span class="type">char</span>)ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            log.log(Level.FINE, var5.toString(), var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">this</span>.error(<span class="string">&quot;expected hessian reply at &quot;</span> + <span class="built_in">this</span>.codeName(tag) + <span class="string">&quot;\n&quot;</span> + sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现会用一个反序列化工厂类去获取结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.findSerializerFactory().getDeserializer(cl).readObject(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">return</span> value;</span><br></pre></td></tr></table></figure><p> 总结：先将要调用的方法和参数等信息写进Output流，发送HTTP，服务端通过流信息将方法调用结果写入Input流，最后返回给客户端  </p><h3 id="服务端处理输出流"><a href="#服务端处理输出流" class="headerlink" title="服务端处理输出流"></a><strong>服务端处理输出流</strong></h3><p>com.caucho.hessian.server.HessianServlet类是javax.servlet.http.HttpServlet的一个子类，所以这个类的init方法将会承担一些初始化的功能，而service方法将会是相关处理的起始位置。<br>init方法：主要涉及_homeImpl（继承HessianServlet的实现类）、_homeAPI（继承HessianServlet的Clas）、_homeSkeleton（HessianSkeleton对象，其父类会封装实现类的方法）变量的初始化<br>service方法：HessianServlet只支持POST请求，若是POST请求会进行如下操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest)request;</span><br><span class="line">    <span class="type">HttpServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> (HttpServletResponse)response;</span><br><span class="line">    <span class="keyword">if</span> (!req.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        res.setStatus(<span class="number">500</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> res.getWriter();</span><br><span class="line">        res.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;Hessian Requires POST&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> req.getPathInfo();</span><br><span class="line">        <span class="type">String</span> <span class="variable">objectId</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (objectId == <span class="literal">null</span>) &#123;</span><br><span class="line">            objectId = req.getParameter(<span class="string">&quot;ejbid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ServiceContext.begin(req, res, serviceId, objectId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">            response.setContentType(<span class="string">&quot;x-application/hessian&quot;</span>);</span><br><span class="line">            <span class="type">SerializerFactory</span> <span class="variable">serializerFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.getSerializerFactory();</span><br><span class="line">            <span class="built_in">this</span>.invoke(is, os, objectId, serializerFactory);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var15) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var15;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException var16) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var16;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(var17);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ServiceContext.end();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入invoke方法看处理逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(InputStream is, OutputStream os, String objectId, SerializerFactory serializerFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (objectId != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._objectSkeleton.invoke(is, os, serializerFactory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._homeSkeleton.invoke(is, os, serializerFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有指定的objectid就会用_homeSkeleton的invoke方法<br>HessianSkeleton 是 AbstractSkeleton 的子类，用来对 Hessian 提供的服务进行封装。这里想起来rmi的skelection<br>首先 AbstractSkeleton 初始化时接收调用接口的类型，并按照自己的逻辑把接口中的方法保存在 _methodMap 中，包括“方法名”、“方法名__方法参数个数”、“方法名_参数类型_参数2类型”等自定义格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractSkeleton</span><span class="params">(Class apiClass)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>._apiClass = apiClass;</span><br><span class="line">Method[] methodList = apiClass.getMethods();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methodList.length; ++i) &#123;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodList[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._methodMap.get(method.getName()) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._methodMap.put(method.getName(), methodList[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class[] param = method.getParameterTypes();</span><br><span class="line">    <span class="type">String</span> <span class="variable">mangledName</span> <span class="operator">=</span> method.getName() + <span class="string">&quot;__&quot;</span> + param.length;</span><br><span class="line">    <span class="built_in">this</span>._methodMap.put(mangledName, methodList[i]);</span><br><span class="line">    <span class="built_in">this</span>._methodMap.put(mangleName(method, <span class="literal">false</span>), methodList[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HessianSkeleton 初始化时将实现类保存在成员变量 _service 中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HessianSkeleton</span><span class="params">(Object service, Class&lt;?&gt; apiClass)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(apiClass);</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">        service = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>._service = service;</span><br><span class="line">    <span class="keyword">if</span> (!apiClass.isAssignableFrom(service.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Service &quot;</span> + service + <span class="string">&quot; must be an instance of &quot;</span> + apiClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看invoke方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HessianInputFactory.<span class="type">HeaderType</span> <span class="variable">header</span> <span class="operator">=</span> <span class="built_in">this</span>._inputFactory.readHeader((InputStream)is);</span><br></pre></td></tr></table></figure><p>去读取协议头种类根据种类去选择是那种数据交换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> CALL_1_REPLY_1:</span><br><span class="line">        in = <span class="built_in">this</span>._hessianFactory.createHessianInput((InputStream)is);</span><br><span class="line">        out = <span class="built_in">this</span>._hessianFactory.createHessianOutput((OutputStream)os);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CALL_1_REPLY_2:</span><br><span class="line">        in = <span class="built_in">this</span>._hessianFactory.createHessianInput((InputStream)is);</span><br><span class="line">        out = <span class="built_in">this</span>._hessianFactory.createHessian2Output((OutputStream)os);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HESSIAN_2:</span><br><span class="line">        in = <span class="built_in">this</span>._hessianFactory.createHessian2Input((InputStream)is);</span><br><span class="line">        ((AbstractHessianInput)in).readCall();</span><br><span class="line">        out = <span class="built_in">this</span>._hessianFactory.createHessian2Output((OutputStream)os);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(header + <span class="string">&quot; is an unknown Hessian call&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 主要是调用方法的查找和参数的反序列化，反序列化后进行反射调用  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] values = <span class="keyword">new</span> <span class="title class_">Object</span>[args.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">    values[i] = in.readObject(args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = method.invoke(service, values);</span><br></pre></td></tr></table></figure><p> 最后写入流中返回  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">in.completeCall();</span><br><span class="line">out.writeReply(result);</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><h3 id="序列化与反序列化流程"><a href="#序列化与反序列化流程" class="headerlink" title="序列化与反序列化流程"></a>序列化与反序列化流程</h3><p>Hessian 的序列化反序列化流程有几个关键类，一般包括输入输出流、序列化&#x2F;反序列化器、相关工厂类等等.<br>首先是输入和输出流，Hessian 定义了 AbstractHessianInput&#x2F;AbstractHessianOutput 两个抽象类，用来提供序列化数据的读取和写入功能。Hessian&#x2F;Hessian2&#x2F;Burlap 都有这两个类各自的实现类来实现具体的逻辑。<br>序列化中，对于输出流关键类为 AbstractHessianOutput 的相关子类，这些类都提供了 call 等相关方法执行方法调用，writeXX 方法进行序列化数据的写入，这里以 Hessian2Output 为例。<br>除了基础数据类型，主要关注的是对 Object 类型数据的写入方法 writeObject：<br>发现会根据指定类型去获取类的序列化器<br><img src="https://baicany.github.io/images/1718524824086-bc656a8d-4920-45f9-870e-cc80c24ef0c9.png" alt="image.png"><br>在当前版本中，可看到一共有 29 个子类针对各种类型的数据。对于自定义类型,就会用JavaSerializer&#x2F;UnsafeSerializer&#x2F;JavaUnsharedSerializer 进行相关的序列化动作，默认情况下是 UnsafeSerializer。<br><img src="https://baicany.github.io/images/1718526059592-62d25727-00bd-4e25-ab98-eb100dbc7128.png" alt="image.png"><br>跟进里面的  loadSerializer 的方法没找到我们想要的类的话就会用getDefaultSerializer获取默认的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (JavaSerializer.getWriteReplace(cl) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">Serializer</span> <span class="variable">baseSerializer</span> <span class="operator">=</span> getDefaultSerializer(cl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WriteReplaceSerializer</span>(cl, getClassLoader(), baseSerializer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDefaultSerializer方法里面就会返回一个UnsafeSerializer<br>UnsafeSerializer#writeObject 方法兼容了 Hessian&#x2F;Hessian2 两种协议的数据结构，会调用 writeObjectBegin 方法开始写入数据<br><img src="https://baicany.github.io/images/1718526309972-743479e3-4f39-4041-b4f7-f111622b4d35.png" alt="image.png"><br>writeObjectBegin 这个方法是 AbstractHessianOutput 的方法，Hessian2Output 重写了这个方法，而其他实现类没有。也就是说在 Hessian 1.0 和 Burlap 中，写入自定义数据类型（Object）时，都会调用 writeMapBegin 方法将其标记为 Map 类型。在 Hessian 2.0 中，将会调用 writeDefinition20 和 Hessian2Output#writeObjectBegin 方法写入自定义数据，就不再将其标记为 Map 类型。<br><img src="https://baicany.github.io/images/1718526640843-a215155b-f40f-45f9-bff6-4df5c81127ac.png" alt="image.png"><br>再看反序列化，对于输入流关键类为 AbstractHessianInput 的子类，这些类中的 readObject 方法定义了反序列化的关键逻辑。基本都是长达 200 行以上的 switch case 语句。在读取标识位后根据不同的数据类型调用相关的处理逻辑。这里还是以 Hessian2Input 为例。<br> <img src="https://baicany.github.io/images/1718526832828-d5a65a15-3d82-4e93-8de3-0bf2642ca609.png" alt="image.png"><br>与序列化过程设计类似，Hessian 定义了 Deserializer 接口，并为不同的类型创建了不同的实现类。这里重点看下对自定义类型对象的读取。<br>在 Hessian 1.0 的 HessianInput 中，没有针对 Object 的读取，而是都将其作为 Map 读取，在序列化的过程中我们也提到，在写入自定义类型时会将其标记为 Map 类型。<br><img src="https://baicany.github.io/images/1718526998488-e990ed9b-eee5-4b62-bf27-b5c758a34596.png" alt="image.png"><br>MapDeserializer#readMap 方法提供了针对 Map 类型数据的处理逻辑。跟据map类型实例化不同的map<br><img src="https://baicany.github.io/images/1718527105827-5054d45b-56ed-4c14-bd52-6b20fd29e698.png" alt="image.png"><br>然后读取内容,将键值put到map中<br><img src="https://baicany.github.io/images/1718527208424-c2773876-6e45-4dab-bde0-6bc71dfd0f81.png" alt="image.png"><br>在 Hessian 2.0 中，则是提供了 UnsafeDeserializer 来对自定义类型数据进行反序列化，关键方法在 readObject 处。<br>通过instantiate方法通过unsafe实例化类,然后再readObject方法中反序列化 读取filed并写入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">readObject</span><span class="params">(AbstractHessianInput in,</span></span><br><span class="line"><span class="params">                         Object []fields)</span></span><br><span class="line"><span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> instantiate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> readObject(in, obj, (FieldDeserializer2 []) fields);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOExceptionWrapper</span>(_type.getName() + <span class="string">&quot;:&quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>在 Java 原生反序列化中，实现了 java.io.Serializable 接口的类才可以反序列化。Hessian 象征性的支持了这种规范，具体的逻辑如下图，在获取默认序列化器时，判断了类是否实现了 Serializable 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Serializer <span class="title function_">getDefaultSerializer</span><span class="params">(Class cl)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>._defaultSerializer != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._defaultSerializer;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Serializable.class.isAssignableFrom(cl) &amp;&amp; !<span class="built_in">this</span>._isAllowNonSerializable) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Serialized class &quot;</span> + cl.getName() + <span class="string">&quot; must implement java.io.Serializable&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Serializer)(<span class="built_in">this</span>._isEnableUnsafeSerializer &amp;&amp; JavaSerializer.getWriteReplace(cl) == <span class="literal">null</span> ? UnsafeSerializer.create(cl) : JavaSerializer.create(cl));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些可以看看su18师傅的</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://su18.org/post/hessian/#%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82">https://nivi4.notion.site/</a><br><a href="https://su18.org/post/hessian/#%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82">https://su18.org/post/hessian/#%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82</a><br><a href="https://goodapple.top/archives/1193">https://goodapple.top/archives/1193</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
